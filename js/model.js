// Generated by CoffeeScript 1.8.0
(function() {
  var Model, Player, Save, Settings, Snapshot, Statistic, levels, loadByStructure, observe, penalties_list, saveByStructure, settingsDesc, settingsFields, storage,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  levels = {
    square: [0.6, 1],
    hospital: [0.3, 0.6],
    resuscitation: [0, 0.3],
    morgue: [-10000, 0]
  };

  penalties_list = [
    {
      "treat": 0,
      "attack": 0
    }, {
      "treat": 0.01,
      "attack": 3
    }, {
      "treat": 0.03,
      "attack": 6
    }, {
      "treat": 0.05,
      "attack": 9
    }, {
      "treat": 0.1,
      "attack": 12
    }
  ];

  settingsFields = ["number", "checkbox"];

  settingsDesc = {
    info: {
      type: "text",
      before: "Помните: настройки обновляются <b>сразу</b>!"
    },
    wiki: {
      type: "text",
      before: "<a href='https://github.com/ktulhy-kun/math_gunplay/wiki'>Как играть</a>"
    },
    stTime: {
      type: "number",
      before: "Продолжительность дня",
      after: "мин",
      def: "20",
      help: "Если вы меняете это поле днём, то изменения вступят в силу только на <b>следующий</b> день"
    },
    maxAttack: {
      type: "number",
      before: "Максимальная атака",
      after: "%",
      def: "15"
    },
    selfDestroyAttack: {
      type: "checkbox",
      after: "Самоубийство (Атака)",
      def: true
    },
    selfDestroyTreat: {
      type: "checkbox",
      after: "Самоубийство (Лечение)",
      def: true
    },
    selfDestroyResuscitation: {
      type: "checkbox",
      after: "Самоубийство (Реанимация)",
      def: false
    },
    hospitalPlus10: {
      type: "checkbox",
      after: "Дополнительные +10 при лечении в госпитале",
      def: true
    },
    nullTreatIfTreatResuscitation: {
      type: "checkbox",
      after: "Обнуление количества лечений при лечении в реанимации",
      def: true
    },
    attackFormula: {
      type: "text",
      before: "Формула расчёта урона:<br>min (10 + Р - Н - 3 * Л, МАКСУРОН)",
      help: "Р -- кол-во решённых задач<br> Н -- кол-во нерешённых задач<br> Л -- кол-во попыток лечения<br> МАКСУРОН -- максимальный урон, см. выше"
    },
    treatFormula: {
      type: "text",
      before: "Формула расчёта лечения:<br>5 * У + Р - Н - 3 * Л - 5",
      help: "У -- кол-во решённых задач из 3-х, остальное см. выше"
    },
    github: {
      type: "text",
      before: "<a href='https://github.com/ktulhy-kun/math_gunplay'>Исходный код</a>"
    }
  };

  observe = function(obj, property, callback) {
    return Object.observe(obj, function(changes) {
      var change;
      for (change in changes) {
        if (property === change.name) {
          callback(change.type, change.oldValue, obj[property]);
        }
      }
      return void 0;
    });
  };

  storage = {
    save: function(key, val) {
      localStorage.setItem(key, JSON.stringify(val));
      return key;
    },
    load: function(key) {
      JSON.parse(localStorage.getItem(key));
      return key;
    },
    "delete": function(key) {
      return localStorage.clear(key);
    }
  };

  saveByStructure = function(structure, isdeepcopy) {
    var backup, element, objectField, objectName, _i, _len, _ref;
    if (isdeepcopy == null) {
      isdeepcopy = false;
    }
    backup = {};
    for (objectName in structures) {
      element = structures[objectName];
      _ref = element.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        objectField = _ref[_i];
        backup[objectName][objectField] = isdeepcopy ? deepCopy(element.obj[objectField]) : element.obj[objectField];
      }
    }
    return backup;
  };

  loadByStructure = function(structure, savedData) {
    var element, objectField, objectName, _results;
    _results = [];
    for (objectName in structures) {
      element = structures[objectName];
      _results.push((function() {
        var _i, _len, _ref, _results1;
        _ref = element.fields;
        _results1 = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          objectField = _ref[_i];
          _results1.push(element.obj[objectField] = savedData[objectName][objectField]);
        }
        return _results1;
      })());
    }
    return _results;
  };

  Snapshot = (function() {
    function Snapshot(_at_structure) {
      this.structure = _at_structure;
      this.datas = [];
      this.current = -1;
      this.add();
    }

    Snapshot.prototype.add = function() {
      var snapshot;
      this.datas = this.datas.slice(0, this.current + 1);
      snapshot = saveByStructure(this.structure, true);
      return this.current += 1;
    };

    Snapshot.prototype.clear = function() {
      this.current = -1;
      this.datas = [];
      return this.add();
    };

    Snapshot.prototype.load = function(id) {
      if (id == null) {
        id = this.current - 1;
      }
      this.current = getValScope(id, [0, this.data.length]);
      return loadByStructure(this.structure, this.datas[this.current]);
    };

    return Snapshot;

  })();

  Save = (function() {
    Save.protocolVersion = 1;

    function Save(_at_structure) {
      this.structure = _at_structure;
      this.saves = storage.load('saves');
      if (this.saves && this.saves.version !== this.protocolVersion) {
        this._setDefault();
      }
    }

    Save.prototype["new"] = function() {
      var id, now;
      now = new Date;
      id = 1488;
      while (__indexOf.call(this.saves.ids, id) >= 0) {
        id = Math.floor(Math.random() * 100000000000000000);
      }
      this.saves.ids[id] = "{#now}";
      _save();
      return _save(id, saveByStructure(this.structure));
    };

    Save.prototype["delete"] = function(id) {
      delete this.saves.ids[id];
      _save();
      return storage["delete"]("save" + id);
    };

    Save.prototype.load = function(id) {
      return loadByStructure(this.structure);
    };

    Save.prototype._save = function(id, data) {
      if (id == null) {
        id = -1;
      }
      if (data == null) {
        data = void 0;
      }
      switch (id) {
        case -1:
          return storage.save('saves', this.saves);
        default:
          return storage.save("save" + id, data);
      }
    };

    Save.prototype._setDefault = function() {
      this.saves = null;
      this.saves = {
        version: this.protocolVersion,
        ids: {}
      };
      return this._save();
    };

    return Save;

  })();

  Settings = (function() {
    Settings.protocolVersion = 1;

    function Settings() {
      this.datas = storage.load('settings');
      if (this.datas && this.datas.version !== this.protocolVersion) {
        this.datas = this._setDefault();
      }
    }

    Settings.prototype._save = function() {
      return storage.save('settings', this.datas);
    };

    Settings.prototype._setDefault = function() {
      var k, v;
      this.datas = null;
      for (k in settingsDesc) {
        v = settingsDesc[k];
        if (__indexOf.call(settingsFields, k) >= 0) {
          this.datas[k] = v.def;
        }
      }
      return this._save();
    };

    Settings.prototype.set = function(name, value) {
      this.datas[name] = value;
      return this._save();
    };

    return Settings;

  })();

  Player = (function() {
    function Player(_at_id, _at_name, _at_settings, _at_statistic) {
      this.id = _at_id;
      this.name = _at_name;
      this.settings = _at_settings;
      this.statistic = _at_statistic;
      this.health = 1;
      this.solved = this.unsolved = this.treatment = penalties_list = 0;
    }

    Player.prototype.setHealth = function(health) {
      return this.health = getValScope(health([0, 1]));
    };

    Player.prototype.incTreatment = function() {
      if ((this.settings.get("nullTreatIfTreatResuscitation")) && (this.getLevel === "resuscitation")) {
        return this.treatment = 0;
      } else {
        return this.treatment += 1;
      }
    };

    Player.prototype.getHealth = function() {
      return this.health;
    };

    Player.prototype.getLevel = function() {
      var level, scope, _ref;
      for (level in levels) {
        scope = levels[level];
        if ((scope[0] < (_ref = this.health) && _ref <= scope[1])) {
          return level;
        }
      }
      return void 0;
    };

    Player.prototype._rawAttack = function() {
      var penalty;
      penalty = penalties_list[this.penalties].attack;
      return 10 + this.solved - this.unsolved - penalty - 3 * this.treatment;
    };

    Player.prototype.getAttackWithoutTreat = function() {
      return (getValScope(this._rawAttack + 3 * this.treatment, [0, this.settings.get("maxAttack")])) / 100;
    };

    Player.prototype.getAttack = function() {
      return (getValScope(this._rawAttack, [0, this.settings.get("maxAttack")])) / 100;
    };

    Player.prototype.getAttackTo = function(player) {
      switch (false) {
        case 0 !== this.health:
          return 0;
        case this.getLevel === player.getLevel:
          return 0;
        case !((this.id === player.id) && (this.getLevel === "resuscitation") && !this.settings.selfDestroyResuscitation):
          return 0;
        case !((this.id === player.id) && !this.settings.selfDestroyAttack):
          return 0;
        default:
          return this.getAttack;
      }
    };

    Player.prototype._rawTreat = function(solved) {
      return 5 * solved + this.solved - this.unsolved - 3 * this.treatment - 5;
    };

    Player.prototype.getTreat = function(solved) {
      var h;
      h = _rawTreat(solved);
      h += ("hospital" === this.getLevel) * (this.settings.get("hospitalPlus10")) * 10;
      return h = getValScope(h, [(this.settings.selfDestroyTreat ? -Infinity : 0), 1 - this.health]);
    };

    Player.prototype.treat = function(solved) {
      var inc;
      inc = getTreat(solved);
      this.setHealth(this.health + inc);
      return this.incTreatment();
    };

    Player.prototype.hit = function(player) {
      var dmg;
      dmg = this.getAttackTo(player);
      player.setHealth(player.health - dmg);
      return this.solved += 1;
    };

    Player.prototype.miss = function() {
      return this.unsolved += 1;
    };

    Player.prototype.penalty = function() {
      return this.penalty = getValScope(this.penalties += 1, [0, penalties_list.lenght() - 1]);
    };

    return Player;

  })();

  Statistic = (function() {
    function Statistic(_at_players) {
      this.players = _at_players;
      this.stats = {
        "all_damage": {
          "title": "Урона нанесено: ",
          "value": 0
        },
        "all_tasks": {
          "title": "Сыгранные задачи: ",
          "value": 0
        },
        "all_treat": {
          "title": "Вылеченно здоровья: ",
          "value": 0
        },
        "solve_percent": {
          "title": "Решённые/все задачи: ",
          "value": 0
        }
      };
    }

    Statistic.prototype.binds = function() {
      return this._bind_damage();
    };

    Statistic.prototype._bind_damage = function() {
      var player, _results;
      _results = [];
      for (player in this.players) {
        _results.push(observe(player, "health", (function(_this) {
          return function(type, oldValue, newValue) {
            var dmg;
            dmg = getValScope(oldValue - newValue, [0, +Infinity]);
            return _this.stats.all_damage.value += dmg;
          };
        })(this)));
      }
      return _results;
    };

    return Statistic;

  })();

  Model = (function() {
    function Model() {
      this.isDay = false;
      this.isGame = false;
      this.time = 0;
      this.timer = void 0;
      this.players = [];
      this.addSnapshot();
      void 0;
    }

    Model.prototype.setDayTimer = function() {
      this.time = this.settings.stTime * 60;
      this.view.updateTime();
      this.timer = setInterval((function(_this) {
        return function() {
          _this.time -= 1;
          if (_this.time <= 0) {
            _this.changeDayNight();
          } else {
            _this.view.updateTime();
          }
          return void 0;
        };
      })(this), 1000);
      return void 0;
    };

    Model.prototype.changeDayNight = function() {
      clearInterval(this.timer);
      if (!this.isGame) {
        this.isGame = true;
        this.isDay = true;
      } else {
        this.isDay = !this.isDay;
      }
      if (this.isDay) {
        this.setDayTimer();
      }
      this.clearSnapshots();
      this.view.updateUI();
      return void 0;
    };

    return Model;

  })();

  window.Model = Model;

}).call(this);

//# sourceMappingURL=model.js.map
